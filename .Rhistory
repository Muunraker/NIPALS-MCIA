norm(global_scores,type="2")
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_norm # matrix containing global loadings as columns
norm(global_loadings,type="2"
norm(global_loadings,type="2")
# Saving result
global_scores <- nipals_result$global_scores/var(nipals_result$global_scores) # matrix containing global scores as columns
var(global_scores)
View(global_scores)
View(nipals_result)
nipals_result <- test$global_scores[,1]
var(global_scores)
nipals_result <- test
var(test$global_scores[,1])
datapath <- "C:/Users/maxim/iCloudDrive/Research/Bioinformatics MCIA submission/NCI60 Example/Data"
data_files <- list.files(path = datapath, pattern = "\\.csv$", full.names = TRUE)
data_blocks <- lapply(data_files, read.csv, header = TRUE)
# Transpose and format
data_blocks <- lapply(data_blocks, function(dataset){
names <-  dataset[,1]
dataset <- as.data.frame(as.matrix(t(dataset[,-1])))
colnames(dataset) <- names
return(dataset)
})
names(data_blocks) <- gsub("\\.csv$", "", list.files(path = datapath, pattern = "\\.csv$"))
data_blocks_res <- list(data_blocks$mrna, data_blocks$miRNA, data_blocks$prot)
names(data_blocks_res) <- c("mrna", "miRNA", "prot")
# test2 <- NIPALS_iter(data_blocks, tol=1e-14)
data_blocks_res <- lapply(data_blocks_res,omicadeInitialization)
test <- nipals_multiblock(data_blocks_res,1, tol=1e-14)
View(test)
test <- nipals_multiblock(data_blocks_res,num_PCs = 1, tol=1e-14)
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000, deflationMethod = 'block'){
num_blocks <- length(data_blocks)
# First NIPALS run
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
global_scores <- nipals_result$global_scores/var(nipals_result$global_scores) # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/var(nipals_result$global_scores) # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/var(nipals_result$global_scores) # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
global_scores <- cbind(global_scores, nipals_result$global_scores)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
test <- nipals_multiblock(data_blocks_res,num_PCs = 1, tol=1e-14)
test2 <- NIPALS_iter(data_blocks, tol=1e-9)
var(test2$global_scores)
test2$global_scores/var(test2$global_scores)
test2$global_scores/drop(var(test2$global_scores))
for(i in 2:1){print(i)}
for(i in 2:2){print(i)}
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000, deflationMethod = 'block'){
num_blocks <- length(data_blocks)
# First NIPALS run
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
test <- nipals_multiblock(data_blocks_res,num_PCs = 1, tol=1e-14)
test <- nipals_multiblock(data_blocks_res,num_PCs = 1, tol=1e-6)
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000, deflationMethod = 'block'){
num_blocks <- length(data_blocks)
# First NIPALS run
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print("this iteration number")
print(i)
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
test <- nipals_multiblock(data_blocks_res,num_PCs = 1, tol=1e-6)
num_PCs = 2
num_PCs>1
num_PCs = 1
num_PCs>1
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000, deflationMethod = 'block'){
num_blocks <- length(data_blocks)
# First NIPALS run
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print("this iteration number")
print(i)
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
test <- nipals_multiblock(data_blocks_res,num_PCs = 1, tol=1e-6)
test <- nipals_multiblock(data_blocks_res,num_PCs = 2, tol=1e-6)
paste("Computing order ", i ," scores")
paste("Computing order", i ,"scores")
NIPALS_iter <- function(ds, tol=1e-10, maxIter=1000){
# Main iteration loop
stopCrit <- 2*tol
covSquared_old <- 0
iter <- 0
gs <- pracma::rand(nrow(ds[[1]]),1) # begin with random global score vector
while(stopCrit > tol && iter <= maxIter){
# Computing block loadings
bl_list <- lapply(ds, function(df,q){
bl_k <- crossprod(as.matrix(df), q)
bl_k <- bl_k/norm(bl_k, type="2")
return(bl_k)
}, q=gs)
# Computing block scores
bs_list <- mapply(function(df,bl_k){
bs_k <- as.matrix(df) %*% bl_k
return(bs_k)
},ds, bl_list)
# Computing global weights
gw <- crossprod(bs_list,gs)
gw <- gw/norm(gw, type="2")
gs <- bs_list %*% gw
# Computing stopping criteria
covList <- sapply(as.data.frame(bs_list), function(bs, gs){
gs_norm <- gs/sqrt(drop(var(gs)))
return(drop(cov(bs,gs_norm))^2)
}, gs = gs)
stopCrit <- abs(sum(covList) - covSquared_old)
covSquared_old <-sum(covList)
iter <- iter +1
print(paste("Iteration number:",iter,", Resisual error:", stopCrit))
}
if(iter > maxIter){
warning('NIPALS iteration did not converge')
}
# Computing global loadings at final iteration
gl <- bl_list[[1]]*gw[1]
nblocks <- length(ds)
for(i in 2:nblocks){
gl <- c(gl, bl_list[[i]]*gw[i])
}
# Returning results
retlist <-list(gs, gl, gw, bs_list, bl_list )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
test <- nipals_multiblock(data_blocks_res,num_PCs = 3, tol=1e-6)
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000, deflationMethod = 'block'){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
test <- nipals_multiblock(data_blocks_res,num_PCs = 3, tol=1e-6)
View(test)
#' @export
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000,
deflationMethod = 'block',){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000,
deflationMethod = 'block',){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-7, max_iter = 1000, deflationMethod = 'block'){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
global_scores <- nipals_result$global_scores/gs_var # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings)/gs_var # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights/gs_var # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
gs_var <- drop(var(nipals_result$global_scores))
global_scores <- cbind(global_scores, nipals_result$global_scores/gs_var)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings/gs_var)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/gs_var)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Returning output:
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
retlist <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(retlist) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
return(retlist)
}
roxygenize
roxygenize()
roxygenise()
library(devtools)
library(roxygen2)
roxygenize()
cd ..
setwd(dir = "..")
setwd(dir = "NIPALS_MCIA/")
roxygenize()
rm(list = c("NIPALS_iter", "nipals_multiblock"))
roxygenize()
rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
# Import Data
datapath <- "C:/Users/maxim/iCloudDrive/Research/Bioinformatics MCIA submission/NCI60 Example/Data"
data_files <- list.files(path = datapath, pattern = "\\.csv$", full.names = TRUE)
data_blocks <- lapply(data_files, read.csv, header = TRUE)
# Transpose and format
data_blocks <- lapply(data_blocks, function(dataset){
names <-  dataset[,1]
dataset <- as.data.frame(as.matrix(t(dataset[,-1])))
colnames(dataset) <- names
return(dataset)
})
names(data_blocks) <- gsub("\\.csv$", "", list.files(path = datapath, pattern = "\\.csv$"))
data_blocks_res <- list(data_blocks$mrna, data_blocks$miRNA, data_blocks$prot)
names(data_blocks_res) <- c("mrna", "miRNA", "prot")
data_blocks_res <- lapply(data_blocks_res,omicadeInitialization)
test <- nipals_multiblock(data_blocks_res,num_PCs = 3, tol=1e-6)
