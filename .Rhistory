rm(list = ls())
# Import Data
datapath <- "C:/Users/maxim/iCloudDrive/Research/Bioinformatics MCIA submission/NCI60 Example/Data"
data_files <- list.files(path = datapath, pattern = "\\.csv$", full.names = TRUE)
data_blocks <- lapply(data_files, read.csv, header = TRUE)
# Transpose and format
data_blocks <- lapply(data_blocks, function(dataset){
names <-  dataset[,1]
dataset <- as.data.frame(as.matrix(t(dataset[,-1])))
colnames(dataset) <- names
return(dataset)
})
names(data_blocks) <- gsub("\\.csv$", "", list.files(path = datapath, pattern = "\\.csv$"))
data_blocks_res <- list(data_blocks$mrna, data_blocks$miRNA, data_blocks$prot)
names(data_blocks_res) <- c("mrna", "miRNA", "prot")
View(data_blocks_res)
save(data_blocks_res, file = "NCI60.rda")
rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
data(NCI60)
View(data_blocks_res)
View(data_blocks_res)
# Import Data
datapath <- "C:/Users/maxim/iCloudDrive/Research/Bioinformatics MCIA submission/NCI60 Example/Data"
data_files <- list.files(path = datapath, pattern = "\\.csv$", full.names = TRUE)
data_blocks <- lapply(data_files, read.csv, header = TRUE)
# Transpose and format
data_blocks <- lapply(data_blocks, function(dataset){
names <-  dataset[,1]
dataset <- as.data.frame(as.matrix(t(dataset[,-1])))
colnames(dataset) <- names
return(dataset)
})
names(data_blocks) <- gsub("\\.csv$", "", list.files(path = datapath, pattern = "\\.csv$"))
data_blocks <- list(data_blocks$mrna, data_blocks$miRNA, data_blocks$prot)
names(data_blocks) <- c("mrna", "miRNA", "prot")
save(data_blocks, file = "NCI60.rda")
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-12, max_iter = 1000,
deflationMethod = 'block',plots="true"){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
# Normalization of GS disabled - breaks block score weights
# gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
# global_scores <- nipals_result$global_scores/sqrt(gs_var) # matrix containing global scores as columns
# global_loadings <- as.matrix(nipals_result$global_loadings)/sqrt(gs_var) # matrix containing global loadings as columns
# block_score_weights <- nipals_result$block_score_weights/sqrt(gs_var) # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
# gs_var <- drop(var(nipals_result$global_scores))
# global_scores <- cbind(global_scores, nipals_result$global_scores/sqrt(gs_var))
# global_loadings <- cbind(global_loadings, nipals_result$global_loadings/sqrt(gs_var))
# block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/sqrt(gs_var))
global_scores <- cbind(global_scores, nipals_result$global_scores)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Formatting results
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
results_list <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(results_list) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
# Plotting results
# Plot 1 - first two scores as (x,y) coordinates
if(tolower(plots) == 'true'){
# Normalize global and block scores to unit variance
gs_norms <- apply(results_list$global_scores,2,function(x){sqrt(var(x))})
gs_normed <- t(t(results_list$global_scores) / gs_norms)
gl_normed <- t(t(results_list$global_loadings) / gs_norms)
gw_normed <- t(t(results_list$block_score_weights) / gs_norms)
bs_normed <- list()
bl_normed <- list()
for(i in 1:length(results_list$block_scores)){
bs_norms <-apply(results_list$block_scores[[i]],2,function(x){sqrt(var(x))})
bs_normed[[i]] <- t(t(results_list$block_scores[[i]]) / bs_norms)
bl_normed[[i]] <- t(t(results_list$block_loadings[[i]]) / bs_norms)
}
# Plotting first two global scores
plot(gs_normed[,1],gs_normed[,2],main = "First Two Global Scores",
xlab="1st Order Scores", ylab="2nd Order Scores",
col="black",
xlim=c(min(gs_normed[,1]), max(gs_normed[,1])),
ylim=c(min(gs_normed[,2]), max(gs_normed[,2])),
cex = .5,pch = 16)
grid()
# Plotting block scores (shapes correspond to different blocks)
for(j in 1:length(bs_normed)){
bs_j <- bs_normed[[j]]
points(bs_j[,1],bs_j[,2], col="black",cex = 1,pch = j-1)
# Line segments joining block scores to central global score:
segments(bs_j[,1],bs_j[,2],gs_normed[,1],gs_normed[,2], col="black")
}
}
return(results_list)
}
data_blocks_norm <- lapply(data_blocks_res,omicadeInitialization)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
data(NCI60)
data_blocks_norm <- lapply(data_blocks,omicadeInitialization)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
test2 <- NIPALS_iter(data_blocks_norm, 1e-12)
test2$global_scores
source("~/NIPALS_MCIA/R/NIPALS_MCIA.R")
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-12, max_iter = 1000,
deflationMethod = 'block',plots="true"){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
# Normalization of GS disabled - breaks block score weights
# gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
# global_scores <- nipals_result$global_scores/sqrt(gs_var) # matrix containing global scores as columns
# global_loadings <- as.matrix(nipals_result$global_loadings)/sqrt(gs_var) # matrix containing global loadings as columns
# block_score_weights <- nipals_result$block_score_weights/sqrt(gs_var) # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
print("FUCK R")
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
# gs_var <- drop(var(nipals_result$global_scores))
# global_scores <- cbind(global_scores, nipals_result$global_scores/sqrt(gs_var))
# global_loadings <- cbind(global_loadings, nipals_result$global_loadings/sqrt(gs_var))
# block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights/sqrt(gs_var))
global_scores <- cbind(global_scores, nipals_result$global_scores)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Formatting results
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
results_list <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(results_list) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
# Plotting results
# Plot 1 - first two scores as (x,y) coordinates
if(tolower(plots) == 'true'){
# Normalize global and block scores to unit variance
gs_norms <- apply(results_list$global_scores,2,function(x){sqrt(var(x))})
gs_normed <- t(t(results_list$global_scores) / gs_norms)
gl_normed <- t(t(results_list$global_loadings) / gs_norms)
gw_normed <- t(t(results_list$block_score_weights) / gs_norms)
bs_normed <- list()
bl_normed <- list()
for(i in 1:length(results_list$block_scores)){
bs_norms <-apply(results_list$block_scores[[i]],2,function(x){sqrt(var(x))})
bs_normed[[i]] <- t(t(results_list$block_scores[[i]]) / bs_norms)
bl_normed[[i]] <- t(t(results_list$block_loadings[[i]]) / bs_norms)
}
# Plotting first two global scores
plot(gs_normed[,1],gs_normed[,2],main = "First Two Global Scores",
xlab="1st Order Scores", ylab="2nd Order Scores",
col="black",
xlim=c(min(gs_normed[,1]), max(gs_normed[,1])),
ylim=c(min(gs_normed[,2]), max(gs_normed[,2])),
cex = .5,pch = 16)
grid()
# Plotting block scores (shapes correspond to different blocks)
for(j in 1:length(bs_normed)){
bs_j <- bs_normed[[j]]
points(bs_j[,1],bs_j[,2], col="black",cex = 1,pch = j-1)
# Line segments joining block scores to central global score:
segments(bs_j[,1],bs_j[,2],gs_normed[,1],gs_normed[,2], col="black")
}
}
return(results_list)
}
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
data(NCI60)
data_blocks_norm <- lapply(data_blocks,omicadeInitialization)
View(data_blocks_norm)
data(NCI60)
data_blocks_norm <- lapply(data_blocks,omicadeInitialization)
View(data_blocks_norm)
test2 <- NIPALS_iter(data_blocks_norm, 1e-12)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-6)
data_blocks <- data_blocks_norm
num_blocks <- length(data_blocks)
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
# Normalization of GS disabled - breaks block score weights
# gs_var <- drop(var(nipals_result$global_scores)) # variance of global score (for normalization)
# global_scores <- nipals_result$global_scores/sqrt(gs_var) # matrix containing global scores as columns
# global_loadings <- as.matrix(nipals_result$global_loadings)/sqrt(gs_var) # matrix containing global loadings as columns
# block_score_weights <- nipals_result$block_score_weights/sqrt(gs_var) # matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
nipals_result <- NIPALS_iter(data_blocks, tol)
tol=1e-12
nipals_result <- NIPALS_iter(data_blocks, tol)
tol=1e-5
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
numPCs = 2
i=2
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
deflationMethod = 'block'
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
View(nipals_result)
global_scores <- cbind(global_scores, nipals_result$global_scores)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights)
nipals_result$global_scores
nipals_result$global_scores
nipals_multiblock <- function(data_blocks, num_PCs=2, tol=1e-12, max_iter = 1000,
deflationMethod = 'block',plots="true"){
num_blocks <- length(data_blocks)
# First NIPALS run
print(paste("Computing order", 1 ,"scores"))
nipals_result <- NIPALS_iter(data_blocks, tol)
# Saving result
global_scores <- nipals_result$global_scores # matrix containing global scores as columns
global_loadings <- as.matrix(nipals_result$global_loadings) # matrix containing global loadings as columns
block_score_weights <- nipals_result$block_score_weights# matrix containing block score weights as columns
block_scores <- list() # list containing matrices of block scores
block_loadings <- list() # list containing matrices of block loadings
for(i in 1:num_blocks){
block_scores[[i]] <- nipals_result$block_scores[,i]
block_loadings[[i]] <- nipals_result$block_loadings[[i]]
}
if(num_PCs>1){
# generate scores/loadings up to number of PCs
for(i in 2:num_PCs){
print(paste("Computing order", i ,"scores"))
# Deflate blocks
if(tolower(deflationMethod) == 'block'){
data_blocks <- mapply(deflate_block_bl, data_blocks, nipals_result$block_loadings)
} else if(tolower(deflationMethod) == 'global'){
data_blocks <- lapply(data_blocks, deflate_block_gs, gs=nipals_result$global_scores)
}else{
stop("Uknown option for deflation step - use 'block' or 'global'")
}
# Run another NIPALS iteration
nipals_result <- NIPALS_iter(data_blocks, tol)
# Save results
global_scores <- cbind(global_scores, nipals_result$global_scores)
global_loadings <- cbind(global_loadings, nipals_result$global_loadings)
block_score_weights <- cbind(block_score_weights, nipals_result$block_score_weights)
for(j in 1:num_blocks){
block_scores[[j]] <- cbind(block_scores[[j]], nipals_result$block_scores[,j])
block_loadings[[j]] <- cbind(block_loadings[[j]], nipals_result$block_loadings[[j]])
}
}
}
# Formatting results
names(block_scores) <- names(data_blocks)
names(block_loadings) <- names(data_blocks)
results_list <-list(global_scores, global_loadings, block_score_weights, block_scores, block_loadings )
names(results_list) <- c('global_scores','global_loadings','block_score_weights','block_scores','block_loadings')
# Plotting results
# Plot 1 - first two scores as (x,y) coordinates
if(tolower(plots) == 'true'){
# Normalize global and block scores to unit variance
gs_norms <- apply(results_list$global_scores,2,function(x){sqrt(var(x))})
gs_normed <- t(t(results_list$global_scores) / gs_norms)
gl_normed <- t(t(results_list$global_loadings) / gs_norms)
gw_normed <- t(t(results_list$block_score_weights) / gs_norms)
bs_normed <- list()
bl_normed <- list()
for(i in 1:length(results_list$block_scores)){
bs_norms <-apply(results_list$block_scores[[i]],2,function(x){sqrt(var(x))})
bs_normed[[i]] <- t(t(results_list$block_scores[[i]]) / bs_norms)
bl_normed[[i]] <- t(t(results_list$block_loadings[[i]]) / bs_norms)
}
# Plotting first two global scores
plot(gs_normed[,1],gs_normed[,2],main = "First Two Global Scores",
xlab="1st Order Scores", ylab="2nd Order Scores",
col="black",
xlim=c(min(gs_normed[,1]), max(gs_normed[,1])),
ylim=c(min(gs_normed[,2]), max(gs_normed[,2])),
cex = .5,pch = 16)
grid()
# Plotting block scores (shapes correspond to different blocks)
for(j in 1:length(bs_normed)){
bs_j <- bs_normed[[j]]
points(bs_j[,1],bs_j[,2], col="black",cex = 1,pch = j-1)
# Line segments joining block scores to central global score:
segments(bs_j[,1],bs_j[,2],gs_normed[,1],gs_normed[,2], col="black")
}
}
return(results_list)
}
rm(list = ls())
rm(list = ls())
install.packages("devtools")
install.packages("devtools")
rm(list = ls())
View(nipals_result)
View(nipals_result)
omicadeInitialization()
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)# WHY IS THIS A DIFFERENT NAME???
data(NCI60)
data_blocks_norm <- lapply(data_blocks,omicadeInitialization)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-6)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
test$global_scores
c("",names(data_blocks))
legend(1,legend = c("",names(data_blocks)))
legend(legend = c("",names(data_blocks)))
legend("topleft",legend = c("",names(data_blocks)))
1:length(data_blocks)
legend("topleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks))
legend("topleft",legend = c(names(data_blocks)),pch = 0:length(data_blocks)-1)
legend("topleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks)-1)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
legend("topleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks)-1)
setwd("..")
setwd("..")
setwd("..")
setwd("..")
setwd("Documents/NIPALS_MCIA/")
library(roxygen2)
roxygenize()
git init
rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)
data(NCI60)
data_blocks_norm <- lapply(data_blocks,omicadeInitialization)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
legend("topleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks)-1,
cex = 0.75)
legend("bottomleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks)-1,
cex = 0.75)
legend("bottomleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks)-1,
cex = 0.6)
legend("bottomleft",legend = c(names(data_blocks)),pch = 1:length(data_blocks)-1,
cex = 0.5)
rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("Muunraker/NIPALS-MCIA",auth_token="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")
library(nipalsMCIA)
data(NCI60)
data_blocks_norm <- lapply(data_blocks,omicadeInitialization)
test <- nipals_multiblock(data_blocks_norm,num_PCs = 2, tol=1e-12)
legend off
legend(off)
Sys.which("pdflatex")
install.packages('tinytex')
tinytex::install_tinytex()
tinytex::pdflatex('NIPALS-MCIA.Rnw')
Sys.getenv("R_ENVIRON")
Sys.getenv("R_HOME")
Sys.which("pdflatex")
